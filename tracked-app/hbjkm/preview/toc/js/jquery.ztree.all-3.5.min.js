var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
    return typeof e;
} : function(e) {
    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
};

!function(k) {
    var F, G, H, I, J, K, r = {}, L = {}, t = {}, M = {
        treeId: "",
        treeObj: null,
        view: {
            addDiyDom: null,
            autoCancelSelected: !0,
            dblClickExpand: !0,
            expandSpeed: "fast",
            fontCss: {},
            nameIsHTML: !1,
            selectedMulti: !0,
            showIcon: !0,
            showLine: !0,
            showTitle: !0
        },
        data: {
            key: {
                children: "children",
                name: "name",
                title: "",
                url: "url"
            },
            simpleData: {
                enable: !1,
                idKey: "id",
                pIdKey: "pId",
                rootPId: null
            },
            keep: {
                parent: !1,
                leaf: !1
            }
        },
        async: {
            enable: !1,
            contentType: "application/x-www-form-urlencoded",
            type: "post",
            dataType: "text",
            url: "",
            autoParam: [],
            otherParam: [],
            dataFilter: null
        },
        callback: {
            beforeAsync: null,
            beforeClick: null,
            beforeDblClick: null,
            beforeRightClick: null,
            beforeMouseDown: null,
            beforeMouseUp: null,
            beforeExpand: null,
            beforeCollapse: null,
            beforeRemove: null,
            onAsyncError: null,
            onAsyncSuccess: null,
            onNodeCreated: null,
            onClick: null,
            onDblClick: null,
            onRightClick: null,
            onMouseDown: null,
            onMouseUp: null,
            onExpand: null,
            onCollapse: null,
            onRemove: null
        }
    }, u = [ function(t) {
        var n = t.treeObj, a = e.event;
        n.bind(a.NODECREATED, function(e, n, a) {
            j.apply(t.callback.onNodeCreated, [ e, n, a ]);
        }), n.bind(a.CLICK, function(e, n, a, o, r) {
            j.apply(t.callback.onClick, [ n, a, o, r ]);
        }), n.bind(a.EXPAND, function(e, n, a) {
            j.apply(t.callback.onExpand, [ e, n, a ]);
        }), n.bind(a.COLLAPSE, function(e, n, a) {
            j.apply(t.callback.onCollapse, [ e, n, a ]);
        }), n.bind(a.ASYNC_SUCCESS, function(e, n, a, o) {
            j.apply(t.callback.onAsyncSuccess, [ e, n, a, o ]);
        }), n.bind(a.ASYNC_ERROR, function(e, n, a, o, r, d) {
            j.apply(t.callback.onAsyncError, [ e, n, a, o, r, d ]);
        });
    } ], v = [ function(t) {
        var n = e.event;
        t.treeObj.unbind(n.NODECREATED).unbind(n.CLICK).unbind(n.EXPAND).unbind(n.COLLAPSE).unbind(n.ASYNC_SUCCESS).unbind(n.ASYNC_ERROR);
    } ], w = [ function(e) {
        var t = h.getCache(e);
        t || (t = {}, h.setCache(e, t)), t.nodes = [], t.doms = [];
    } ], x = [ function(e, t, n, a, o, r) {
        if (n) {
            var d = h.getRoot(e), i = e.data.key.children;
            n.level = t, n.tId = e.treeId + "_" + ++d.zId, n.parentTId = a ? a.tId : null, n[i] && n[i].length > 0 ? ("string" == typeof n.open && (n.open = j.eqs(n.open, "true")), 
            n.open = !!n.open, n.isParent = !0, n.zAsync = !0) : (n.open = !1, "string" == typeof n.isParent && (n.isParent = j.eqs(n.isParent, "true")), 
            n.isParent = !!n.isParent, n.zAsync = !n.isParent), n.isFirstNode = o, n.isLastNode = r, 
            n.getParentNode = function() {
                return h.getNodeCache(e, n.parentTId);
            }, n.getPreNode = function() {
                return h.getPreNode(e, n);
            }, n.getNextNode = function() {
                return h.getNextNode(e, n);
            }, n.isAjaxing = !1, h.fixPIdKeyValue(e, n);
        }
    } ], y = [ function(t) {
        var n = t.target, a = h.getSetting(t.data.treeId), o = "", r = null, d = "", i = "", l = null, s = null, c = null;
        if (j.eqs(t.type, "mousedown") ? i = "mousedown" : j.eqs(t.type, "mouseup") ? i = "mouseup" : j.eqs(t.type, "contextmenu") ? i = "contextmenu" : j.eqs(t.type, "click") ? j.eqs(n.tagName, "span") && null !== n.getAttribute("treeNode" + e.id.SWITCH) ? (o = (k(n).parent("li").get(0) || k(n).parentsUntil("li").parent().get(0)).id, 
        d = "switchNode") : (c = j.getMDom(a, n, [ {
            tagName: "a",
            attrName: "treeNode" + e.id.A
        } ])) && (o = (k(c).parent("li").get(0) || k(c).parentsUntil("li").parent().get(0)).id, 
        d = "clickNode") : j.eqs(t.type, "dblclick") && (i = "dblclick", c = j.getMDom(a, n, [ {
            tagName: "a",
            attrName: "treeNode" + e.id.A
        } ])) && (o = (k(c).parent("li").get(0) || k(c).parentsUntil("li").parent().get(0)).id, 
        d = "switchNode"), i.length > 0 && 0 == o.length && (c = j.getMDom(a, n, [ {
            tagName: "a",
            attrName: "treeNode" + e.id.A
        } ])) && (o = (k(c).parent("li").get(0) || k(c).parentsUntil("li").parent().get(0)).id), 
        o.length > 0) switch (r = h.getNodeCache(a, o), d) {
          case "switchNode":
            r.isParent && (j.eqs(t.type, "click") || j.eqs(t.type, "dblclick") && j.apply(a.view.dblClickExpand, [ a.treeId, r ], a.view.dblClickExpand)) ? l = F : d = "";
            break;

          case "clickNode":
            l = G;
        }
        switch (i) {
          case "mousedown":
            s = H;
            break;

          case "mouseup":
            s = I;
            break;

          case "dblclick":
            s = J;
            break;

          case "contextmenu":
            s = K;
        }
        return {
            stop: !1,
            node: r,
            nodeEventType: d,
            nodeEventCallback: l,
            treeEventType: i,
            treeEventCallback: s
        };
    } ], z = [ function(e) {
        var t = h.getRoot(e);
        t || (t = {}, h.setRoot(e, t)), t[e.data.key.children] = [], t.expandTriggerFlag = !1, 
        t.curSelectedList = [], t.noSelection = !0, t.createdNodes = [], t.zId = 0, t._ver = new Date().getTime();
    } ], A = [], B = [], C = [], D = [], E = [], h = {
        addNodeCache: function(e, t) {
            h.getCache(e).nodes[h.getNodeCacheId(t.tId)] = t;
        },
        getNodeCacheId: function(e) {
            return e.substring(e.lastIndexOf("_") + 1);
        },
        addAfterA: function(e) {
            B.push(e);
        },
        addBeforeA: function(e) {
            A.push(e);
        },
        addInnerAfterA: function(e) {
            D.push(e);
        },
        addInnerBeforeA: function(e) {
            C.push(e);
        },
        addInitBind: function(e) {
            u.push(e);
        },
        addInitUnBind: function(e) {
            v.push(e);
        },
        addInitCache: function(e) {
            w.push(e);
        },
        addInitNode: function(e) {
            x.push(e);
        },
        addInitProxy: function(e) {
            y.push(e);
        },
        addInitRoot: function(e) {
            z.push(e);
        },
        addNodesData: function(e, t, n) {
            var a = e.data.key.children;
            t[a] || (t[a] = []), t[a].length > 0 && (t[a][t[a].length - 1].isLastNode = !1, 
            i.setNodeLineIcos(e, t[a][t[a].length - 1])), t.isParent = !0, t[a] = t[a].concat(n);
        },
        addSelectedNode: function(e, t) {
            var n = h.getRoot(e);
            h.isSelectedNode(e, t) || n.curSelectedList.push(t);
        },
        addCreatedNode: function(e, t) {
            (e.callback.onNodeCreated || e.view.addDiyDom) && h.getRoot(e).createdNodes.push(t);
        },
        addZTreeTools: function(e) {
            E.push(e);
        },
        exSetting: function(e) {
            k.extend(!0, M, e);
        },
        fixPIdKeyValue: function(e, t) {
            e.data.simpleData.enable && (t[e.data.simpleData.pIdKey] = t.parentTId ? t.getParentNode()[e.data.simpleData.idKey] : e.data.simpleData.rootPId);
        },
        getAfterA: function(e, t, n) {
            for (var a = 0, o = B.length; a < o; a++) B[a].apply(this, arguments);
        },
        getBeforeA: function(e, t, n) {
            for (var a = 0, o = A.length; a < o; a++) A[a].apply(this, arguments);
        },
        getInnerAfterA: function(e, t, n) {
            for (var a = 0, o = D.length; a < o; a++) D[a].apply(this, arguments);
        },
        getInnerBeforeA: function(e, t, n) {
            for (var a = 0, o = C.length; a < o; a++) C[a].apply(this, arguments);
        },
        getCache: function(e) {
            return t[e.treeId];
        },
        getNextNode: function(e, t) {
            if (!t) return null;
            for (var n = e.data.key.children, a = t.parentTId ? t.getParentNode() : h.getRoot(e), o = 0, r = a[n].length - 1; o <= r; o++) if (a[n][o] === t) return o == r ? null : a[n][o + 1];
            return null;
        },
        getNodeByParam: function(e, t, n, a) {
            if (!t || !n) return null;
            for (var o = e.data.key.children, r = 0, d = t.length; r < d; r++) {
                if (t[r][n] == a) return t[r];
                var i = h.getNodeByParam(e, t[r][o], n, a);
                if (i) return i;
            }
            return null;
        },
        getNodeCache: function(e, n) {
            if (!n) return null;
            var a = t[e.treeId].nodes[h.getNodeCacheId(n)];
            return a || null;
        },
        getNodeName: function(e, t) {
            return "" + t[e.data.key.name];
        },
        getNodeTitle: function(e, t) {
            return "" + t["" === e.data.key.title ? e.data.key.name : e.data.key.title];
        },
        getNodes: function(e) {
            return h.getRoot(e)[e.data.key.children];
        },
        getNodesByParam: function(e, t, n, a) {
            if (!t || !n) return [];
            for (var o = e.data.key.children, r = [], d = 0, i = t.length; d < i; d++) t[d][n] == a && r.push(t[d]), 
            r = r.concat(h.getNodesByParam(e, t[d][o], n, a));
            return r;
        },
        getNodesByParamFuzzy: function(e, t, n, a) {
            if (!t || !n) return [];
            for (var o = e.data.key.children, r = [], d = 0, i = t.length; d < i; d++) "string" == typeof t[d][n] && t[d][n].indexOf(a) > -1 && r.push(t[d]), 
            r = r.concat(h.getNodesByParamFuzzy(e, t[d][o], n, a));
            return r;
        },
        getNodesByFilter: function(e, t, n, a, o) {
            if (!t) return a ? null : [];
            for (var r = e.data.key.children, d = a ? null : [], i = 0, l = t.length; i < l; i++) {
                if (j.apply(n, [ t[i], o ], !1)) {
                    if (a) return t[i];
                    d.push(t[i]);
                }
                var s = h.getNodesByFilter(e, t[i][r], n, a, o);
                if (a && s) return s;
                d = a ? s : d.concat(s);
            }
            return d;
        },
        getPreNode: function(e, t) {
            if (!t) return null;
            for (var n = e.data.key.children, a = t.parentTId ? t.getParentNode() : h.getRoot(e), o = 0, r = a[n].length; o < r; o++) if (a[n][o] === t) return 0 == o ? null : a[n][o - 1];
            return null;
        },
        getRoot: function(e) {
            return e ? L[e.treeId] : null;
        },
        getSetting: function(e) {
            return r[e];
        },
        getSettings: function() {
            return r;
        },
        getZTreeTools: function(e) {
            return (e = this.getRoot(this.getSetting(e))) ? e.treeTools : null;
        },
        initCache: function(e) {
            for (var t = 0, n = w.length; t < n; t++) w[t].apply(this, arguments);
        },
        initNode: function(e, t, n, a, o, r) {
            for (var d = 0, i = x.length; d < i; d++) x[d].apply(this, arguments);
        },
        initRoot: function(e) {
            for (var t = 0, n = z.length; t < n; t++) z[t].apply(this, arguments);
        },
        isSelectedNode: function(e, t) {
            for (var n = h.getRoot(e), a = 0, o = n.curSelectedList.length; a < o; a++) if (t === n.curSelectedList[a]) return !0;
            return !1;
        },
        removeNodeCache: function(e, t) {
            var n = e.data.key.children;
            if (t[n]) for (var a = 0, o = t[n].length; a < o; a++) arguments.callee(e, t[n][a]);
            h.getCache(e).nodes[h.getNodeCacheId(t.tId)] = null;
        },
        removeSelectedNode: function(e, t) {
            for (var n = h.getRoot(e), a = 0, o = n.curSelectedList.length; a < o; a++) t !== n.curSelectedList[a] && h.getNodeCache(e, n.curSelectedList[a].tId) || (n.curSelectedList.splice(a, 1), 
            a--, o--);
        },
        setCache: function(e, n) {
            t[e.treeId] = n;
        },
        setRoot: function(e, t) {
            L[e.treeId] = t;
        },
        setZTreeTools: function(e, t) {
            for (var n = 0, a = E.length; n < a; n++) E[n].apply(this, arguments);
        },
        transformToArrayFormat: function(e, t) {
            if (!t) return [];
            var n = e.data.key.children, a = [];
            if (j.isArray(t)) for (var o = 0, r = t.length; o < r; o++) a.push(t[o]), t[o][n] && (a = a.concat(h.transformToArrayFormat(e, t[o][n]))); else a.push(t), 
            t[n] && (a = a.concat(h.transformToArrayFormat(e, t[n])));
            return a;
        },
        transformTozTreeFormat: function(e, t) {
            var n, a, o = e.data.simpleData.idKey, r = e.data.simpleData.pIdKey, d = e.data.key.children;
            if (!o || "" == o || !t) return [];
            if (j.isArray(t)) {
                var i = [], l = [];
                for (n = 0, a = t.length; n < a; n++) l[t[n][o]] = t[n];
                for (n = 0, a = t.length; n < a; n++) l[t[n][r]] && t[n][o] != t[n][r] ? (l[t[n][r]][d] || (l[t[n][r]][d] = []), 
                l[t[n][r]][d].push(t[n])) : i.push(t[n]);
                return i;
            }
            return [ t ];
        }
    }, m = {
        bindEvent: function(e) {
            for (var t = 0, n = u.length; t < n; t++) u[t].apply(this, arguments);
        },
        unbindEvent: function(e) {
            for (var t = 0, n = v.length; t < n; t++) v[t].apply(this, arguments);
        },
        bindTree: function(e) {
            var t = {
                treeId: e.treeId
            };
            (e = e.treeObj).bind("selectstart", function(e) {
                return "input" === (e = e.srcElement.nodeName.toLowerCase()) || "textarea" === e;
            }).css({
                "-moz-user-select": "-moz-none"
            }), e.bind("click", t, m.proxy), e.bind("dblclick", t, m.proxy), e.bind("mouseover", t, m.proxy), 
            e.bind("mouseout", t, m.proxy), e.bind("mousedown", t, m.proxy), e.bind("mouseup", t, m.proxy), 
            e.bind("contextmenu", t, m.proxy);
        },
        unbindTree: function(e) {
            e.treeObj.unbind("click", m.proxy).unbind("dblclick", m.proxy).unbind("mouseover", m.proxy).unbind("mouseout", m.proxy).unbind("mousedown", m.proxy).unbind("mouseup", m.proxy).unbind("contextmenu", m.proxy);
        },
        doProxy: function(e) {
            for (var t = [], n = 0, a = y.length; n < a; n++) {
                var o = y[n].apply(this, arguments);
                if (t.push(o), o.stop) break;
            }
            return t;
        },
        proxy: function(e) {
            var t = h.getSetting(e.data.treeId);
            if (!j.uCanDo(t, e)) return !0;
            for (var n = !0, a = 0, o = (t = m.doProxy(e)).length; a < o; a++) {
                var r = t[a];
                r.nodeEventCallback && (n = r.nodeEventCallback.apply(r, [ e, r.node ]) && n), r.treeEventCallback && (n = r.treeEventCallback.apply(r, [ e, r.node ]) && n);
            }
            return n;
        }
    };
    F = function(e, t) {
        var n = h.getSetting(e.data.treeId);
        if (t.open) {
            if (0 == j.apply(n.callback.beforeCollapse, [ n.treeId, t ], !0)) return !0;
        } else if (0 == j.apply(n.callback.beforeExpand, [ n.treeId, t ], !0)) return !0;
        return h.getRoot(n).expandTriggerFlag = !0, i.switchNode(n, t), !0;
    }, G = function(t, n) {
        var a = h.getSetting(t.data.treeId), o = a.view.autoCancelSelected && t.ctrlKey && h.isSelectedNode(a, n) ? 0 : a.view.autoCancelSelected && t.ctrlKey && a.view.selectedMulti ? 2 : 1;
        return 0 == j.apply(a.callback.beforeClick, [ a.treeId, n, o ], !0) || (0 === o ? i.cancelPreSelectedNode(a, n) : i.selectNode(a, n, 2 === o), 
        a.treeObj.trigger(e.event.CLICK, [ t, a.treeId, n, o ]), !0);
    }, H = function(e, t) {
        var n = h.getSetting(e.data.treeId);
        return j.apply(n.callback.beforeMouseDown, [ n.treeId, t ], !0) && j.apply(n.callback.onMouseDown, [ e, n.treeId, t ]), 
        !0;
    }, I = function(e, t) {
        var n = h.getSetting(e.data.treeId);
        return j.apply(n.callback.beforeMouseUp, [ n.treeId, t ], !0) && j.apply(n.callback.onMouseUp, [ e, n.treeId, t ]), 
        !0;
    }, J = function(e, t) {
        var n = h.getSetting(e.data.treeId);
        return j.apply(n.callback.beforeDblClick, [ n.treeId, t ], !0) && j.apply(n.callback.onDblClick, [ e, n.treeId, t ]), 
        !0;
    }, K = function(e, t) {
        var n = h.getSetting(e.data.treeId);
        return j.apply(n.callback.beforeRightClick, [ n.treeId, t ], !0) && j.apply(n.callback.onRightClick, [ e, n.treeId, t ]), 
        "function" != typeof n.callback.onRightClick;
    };
    var j = {
        apply: function(e, t, n) {
            return "function" == typeof e ? e.apply(N, t || []) : n;
        },
        canAsync: function(e, t) {
            var n = e.data.key.children;
            return e.async.enable && t && t.isParent && !(t.zAsync || t[n] && t[n].length > 0);
        },
        clone: function(e) {
            if (null === e) return null;
            var t, n = e.constructor === Array ? [] : {};
            for (t in e) n[t] = e[t] instanceof Date ? new Date(e[t].getTime()) : "object" === _typeof(e[t]) ? arguments.callee(e[t]) : e[t];
            return n;
        },
        eqs: function(e, t) {
            return e.toLowerCase() === t.toLowerCase();
        },
        isArray: function(e) {
            return "[object Array]" === Object.prototype.toString.apply(e);
        },
        getMDom: function(e, t, n) {
            if (!t) return null;
            for (;t && t.id !== e.treeId; ) {
                for (var a = 0, o = n.length; t.tagName && a < o; a++) if (j.eqs(t.tagName, n[a].tagName) && null !== t.getAttribute(n[a].attrName)) return t;
                t = t.parentNode;
            }
            return null;
        },
        uCanDo: function() {
            return !0;
        }
    }, i = {
        addNodes: function(t, n, a, o) {
            if (!t.data.keep.leaf || !n || n.isParent) if (j.isArray(a) || (a = [ a ]), t.data.simpleData.enable && (a = h.transformTozTreeFormat(t, a)), 
            n) {
                var r = k("#" + n.tId + e.id.SWITCH), d = k("#" + n.tId + e.id.ICON), l = k("#" + n.tId + e.id.UL);
                n.open || (i.replaceSwitchClass(n, r, e.folder.CLOSE), i.replaceIcoClass(n, d, e.folder.CLOSE), 
                n.open = !1, l.css({
                    display: "none"
                })), h.addNodesData(t, n, a), i.createNodes(t, n.level + 1, a, n), o || i.expandCollapseParentNode(t, n, !0);
            } else h.addNodesData(t, h.getRoot(t), a), i.createNodes(t, 0, a, null);
        },
        appendNodes: function(e, t, n, a, o, r) {
            if (!n) return [];
            for (var d = [], l = e.data.key.children, s = 0, c = n.length; s < c; s++) {
                var u = n[s];
                if (o) {
                    var p = (a || h.getRoot(e))[l].length == n.length && 0 == s;
                    h.initNode(e, t, u, a, p, s == n.length - 1, r), h.addNodeCache(e, u);
                }
                p = [], u[l] && u[l].length > 0 && (p = i.appendNodes(e, t + 1, u[l], u, o, r && u.open)), 
                r && (i.makeDOMNodeMainBefore(d, e, u), i.makeDOMNodeLine(d, e, u), h.getBeforeA(e, u, d), 
                i.makeDOMNodeNameBefore(d, e, u), h.getInnerBeforeA(e, u, d), i.makeDOMNodeIcon(d, e, u), 
                h.getInnerAfterA(e, u, d), i.makeDOMNodeNameAfter(d, e, u), h.getAfterA(e, u, d), 
                u.isParent && u.open && i.makeUlHtml(e, u, d, p.join("")), i.makeDOMNodeMainAfter(d, e, u), 
                h.addCreatedNode(e, u));
            }
            return d;
        },
        appendParentULDom: function(t, n) {
            var a = [], o = k("#" + n.tId), r = k("#" + n.tId + e.id.UL), d = i.appendNodes(t, n.level + 1, n[t.data.key.children], n, !1, !0);
            i.makeUlHtml(t, n, a, d.join("")), !o.get(0) && n.parentTId && (i.appendParentULDom(t, n.getParentNode()), 
            o = k("#" + n.tId)), r.get(0) && r.remove(), o.append(a.join(""));
        },
        asyncNode: function asyncNode(b, a, c, d) {
            var f, g;
            if (a && !a.isParent) return j.apply(d), !1;
            if (a && a.isAjaxing) return !1;
            if (0 == j.apply(b.callback.beforeAsync, [ b.treeId, a ], !0)) return j.apply(d), 
            !1;
            a && (a.isAjaxing = !0, k("#" + a.tId + e.id.ICON).attr({
                style: "",
                class: "button ico_loading"
            }));
            var l = {};
            for (f = 0, g = b.async.autoParam.length; a && f < g; f++) {
                var q = b.async.autoParam[f].split("="), n = q;
                q.length > 1 && (n = q[1], q = q[0]), l[n] = a[q];
            }
            if (j.isArray(b.async.otherParam)) for (f = 0, g = b.async.otherParam.length; f < g; f += 2) l[b.async.otherParam[f]] = b.async.otherParam[f + 1]; else for (var m in b.async.otherParam) l[m] = b.async.otherParam[m];
            var o = h.getRoot(b)._ver;
            return k.ajax({
                contentType: b.async.contentType,
                type: b.async.type,
                url: j.apply(b.async.url, [ b.treeId, a ], b.async.url),
                data: l,
                dataType: b.async.dataType,
                success: function success(f) {
                    if (o == h.getRoot(b)._ver) {
                        var g = [];
                        try {
                            g = f && 0 != f.length ? "string" == typeof f ? eval("(" + f + ")") : f : [];
                        } catch (e) {
                            g = f;
                        }
                        a && (a.isAjaxing = null, a.zAsync = !0), i.setNodeLineIcos(b, a), g && "" !== g ? (g = j.apply(b.async.dataFilter, [ b.treeId, a, g ], g), 
                        i.addNodes(b, a, g ? j.clone(g) : [], !!c)) : i.addNodes(b, a, [], !!c), b.treeObj.trigger(e.event.ASYNC_SUCCESS, [ b.treeId, a, f ]), 
                        j.apply(d);
                    }
                },
                error: function(t, n, r) {
                    o == h.getRoot(b)._ver && (a && (a.isAjaxing = null), i.setNodeLineIcos(b, a), b.treeObj.trigger(e.event.ASYNC_ERROR, [ b.treeId, a, t, n, r ]));
                }
            }), !0;
        },
        cancelPreSelectedNode: function(t, n) {
            for (var a = h.getRoot(t).curSelectedList, o = a.length - 1; o >= 0; o--) if ((!n || n === a[o]) && (k("#" + a[o].tId + e.id.A).removeClass(e.node.CURSELECTED), 
            n)) {
                h.removeSelectedNode(t, n);
                break;
            }
            n || (h.getRoot(t).curSelectedList = []);
        },
        createNodeCallback: function(t) {
            if (t.callback.onNodeCreated || t.view.addDiyDom) for (var n = h.getRoot(t); n.createdNodes.length > 0; ) {
                var a = n.createdNodes.shift();
                j.apply(t.view.addDiyDom, [ t.treeId, a ]), t.callback.onNodeCreated && t.treeObj.trigger(e.event.NODECREATED, [ t.treeId, a ]);
            }
        },
        createNodes: function(t, n, a, o) {
            if (a && 0 != a.length) {
                var r = h.getRoot(t), d = t.data.key.children, d = !o || o.open || !!k("#" + o[d][0].tId).get(0);
                r.createdNodes = [], n = i.appendNodes(t, n, a, o, !0, d), o ? (o = k("#" + o.tId + e.id.UL)).get(0) && o.append(n.join("")) : t.treeObj.append(n.join("")), 
                i.createNodeCallback(t);
            }
        },
        destroy: function(e) {
            e && (h.initCache(e), h.initRoot(e), m.unbindTree(e), m.unbindEvent(e), e.treeObj.empty());
        },
        expandCollapseNode: function(t, n, a, o, r) {
            var d = h.getRoot(t), l = t.data.key.children;
            if (n) {
                if (d.expandTriggerFlag) {
                    var s = r, r = function() {
                        s && s(), n.open ? t.treeObj.trigger(e.event.EXPAND, [ t.treeId, n ]) : t.treeObj.trigger(e.event.COLLAPSE, [ t.treeId, n ]);
                    };
                    d.expandTriggerFlag = !1;
                }
                if (!n.open && n.isParent && (!k("#" + n.tId + e.id.UL).get(0) || n[l] && n[l].length > 0 && !k("#" + n[l][0].tId).get(0)) && (i.appendParentULDom(t, n), 
                i.createNodeCallback(t)), n.open == a) j.apply(r, []); else {
                    var a = k("#" + n.tId + e.id.UL), d = k("#" + n.tId + e.id.SWITCH), c = k("#" + n.tId + e.id.ICON);
                    n.isParent ? (n.open = !n.open, n.iconOpen && n.iconClose && c.attr("style", i.makeNodeIcoStyle(t, n)), 
                    n.open ? (i.replaceSwitchClass(n, d, e.folder.OPEN), i.replaceIcoClass(n, c, e.folder.OPEN), 
                    0 == o || "" == t.view.expandSpeed ? (a.show(), j.apply(r, [])) : n[l] && n[l].length > 0 ? a.slideDown(t.view.expandSpeed, r) : (a.show(), 
                    j.apply(r, []))) : (i.replaceSwitchClass(n, d, e.folder.CLOSE), i.replaceIcoClass(n, c, e.folder.CLOSE), 
                    0 != o && "" != t.view.expandSpeed && n[l] && n[l].length > 0 ? a.slideUp(t.view.expandSpeed, r) : (a.hide(), 
                    j.apply(r, [])))) : j.apply(r, []);
                }
            } else j.apply(r, []);
        },
        expandCollapseParentNode: function(e, t, n, a, o) {
            t && (t.parentTId ? (i.expandCollapseNode(e, t, n, a), t.parentTId && i.expandCollapseParentNode(e, t.getParentNode(), n, a, o)) : i.expandCollapseNode(e, t, n, a, o));
        },
        expandCollapseSonNode: function(e, t, n, a, o) {
            var r = h.getRoot(e), d = e.data.key.children, r = t ? t[d] : r[d], d = !t && a, l = h.getRoot(e).expandTriggerFlag;
            if (h.getRoot(e).expandTriggerFlag = !1, r) for (var s = 0, c = r.length; s < c; s++) r[s] && i.expandCollapseSonNode(e, r[s], n, d);
            h.getRoot(e).expandTriggerFlag = l, i.expandCollapseNode(e, t, n, a, o);
        },
        makeDOMNodeIcon: function(t, n, a) {
            var o = h.getNodeName(n, a), o = n.view.nameIsHTML ? o : o.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            t.push("<span id='", a.tId, e.id.ICON, "' title='' treeNode", e.id.ICON, " class='", i.makeNodeIcoClass(n, a), "' style='", i.makeNodeIcoStyle(n, a), "'></span><span id='", a.tId, e.id.SPAN, "'>", o, "</span>");
        },
        makeDOMNodeLine: function(t, n, a) {
            t.push("<span id='", a.tId, e.id.SWITCH, "' title='' class='", i.makeNodeLineClass(n, a), "' treeNode", e.id.SWITCH, "></span>");
        },
        makeDOMNodeMainAfter: function(e) {
            e.push("</li>");
        },
        makeDOMNodeMainBefore: function(e, t, n) {
            e.push("<li id='", n.tId, "' class='level", n.level, "' tabindex='0' hidefocus='true' treenode>");
        },
        makeDOMNodeNameAfter: function(e) {
            e.push("</a>");
        },
        makeDOMNodeNameBefore: function(t, n, a) {
            var o, r = h.getNodeTitle(n, a), d = i.makeNodeUrl(n, a), l = i.makeNodeFontCss(n, a), s = [];
            for (o in l) s.push(o, ":", l[o], ";");
            t.push("<a id='", a.tId, e.id.A, "' class='level", a.level, "' treeNode", e.id.A, ' onclick="', a.click || "", '" ', null != d && d.length > 0 ? "href='" + d + "'" : "", " target='", i.makeNodeTarget(a), "' style='", s.join(""), "'"), 
            j.apply(n.view.showTitle, [ n.treeId, a ], n.view.showTitle) && r && t.push("title='", r.replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "'"), 
            t.push(">");
        },
        makeNodeFontCss: function(e, t) {
            var n = j.apply(e.view.fontCss, [ e.treeId, t ], e.view.fontCss);
            return n && "function" != typeof n ? n : {};
        },
        makeNodeIcoClass: function(t, n) {
            var a = [ "ico" ];
            return n.isAjaxing || (a[0] = (n.iconSkin ? n.iconSkin + "_" : "") + a[0], n.isParent ? a.push(n.open ? e.folder.OPEN : e.folder.CLOSE) : a.push(e.folder.DOCU)), 
            "button " + a.join("_");
        },
        makeNodeIcoStyle: function(e, t) {
            var n = [];
            if (!t.isAjaxing) {
                var a = t.isParent && t.iconOpen && t.iconClose ? t.open ? t.iconOpen : t.iconClose : t.icon;
                a && n.push("background:url(", a, ") 0 0 no-repeat;"), (0 == e.view.showIcon || !j.apply(e.view.showIcon, [ e.treeId, t ], !0)) && n.push("width:0px;height:0px;");
            }
            return n.join("");
        },
        makeNodeLineClass: function(t, n) {
            var a = [];
            return t.view.showLine ? 0 == n.level && n.isFirstNode && n.isLastNode ? a.push(e.line.ROOT) : 0 == n.level && n.isFirstNode ? a.push(e.line.ROOTS) : n.isLastNode ? a.push(e.line.BOTTOM) : a.push(e.line.CENTER) : a.push(e.line.NOLINE), 
            n.isParent ? a.push(n.open ? e.folder.OPEN : e.folder.CLOSE) : a.push(e.folder.DOCU), 
            i.makeNodeLineClassEx(n) + a.join("_");
        },
        makeNodeLineClassEx: function(e) {
            return "button level" + e.level + " switch ";
        },
        makeNodeTarget: function(e) {
            return e.target || "_blank";
        },
        makeNodeUrl: function(e, t) {
            var n = e.data.key.url;
            return t[n] ? t[n] : null;
        },
        makeUlHtml: function(t, n, a, o) {
            a.push("<ul id='", n.tId, e.id.UL, "' class='level", n.level, " ", i.makeUlLineClass(t, n), "' style='display:", n.open ? "block" : "none", "'>"), 
            a.push(o), a.push("</ul>");
        },
        makeUlLineClass: function(t, n) {
            return t.view.showLine && !n.isLastNode ? e.line.LINE : "";
        },
        removeChildNodes: function(t, n) {
            if (n) {
                var a = t.data.key.children, o = n[a];
                if (o) {
                    for (var r = 0, d = o.length; r < d; r++) h.removeNodeCache(t, o[r]);
                    h.removeSelectedNode(t), delete n[a], t.data.keep.parent ? k("#" + n.tId + e.id.UL).empty() : (n.isParent = !1, 
                    n.open = !1, a = k("#" + n.tId + e.id.SWITCH), o = k("#" + n.tId + e.id.ICON), i.replaceSwitchClass(n, a, e.folder.DOCU), 
                    i.replaceIcoClass(n, o, e.folder.DOCU), k("#" + n.tId + e.id.UL).remove());
                }
            }
        },
        setFirstNode: function(e, t) {
            var n = e.data.key.children;
            t[n].length > 0 && (t[n][0].isFirstNode = !0);
        },
        setLastNode: function(e, t) {
            var n = e.data.key.children, a = t[n].length;
            a > 0 && (t[n][a - 1].isLastNode = !0);
        },
        removeNode: function(t, n) {
            var a = h.getRoot(t), o = t.data.key.children, r = n.parentTId ? n.getParentNode() : a;
            if (n.isFirstNode = !1, n.isLastNode = !1, n.getPreNode = function() {
                return null;
            }, n.getNextNode = function() {
                return null;
            }, h.getNodeCache(t, n.tId)) {
                k("#" + n.tId).remove(), h.removeNodeCache(t, n), h.removeSelectedNode(t, n);
                for (var d = 0, l = r[o].length; d < l; d++) if (r[o][d].tId == n.tId) {
                    r[o].splice(d, 1);
                    break;
                }
                i.setFirstNode(t, r), i.setLastNode(t, r);
                var s, d = r[o].length;
                if (t.data.keep.parent || 0 != d) {
                    if (t.view.showLine && d > 0) {
                        var c = r[o][d - 1], d = k("#" + c.tId + e.id.UL), l = k("#" + c.tId + e.id.SWITCH);
                        s = k("#" + c.tId + e.id.ICON), r == a ? 1 == r[o].length ? i.replaceSwitchClass(c, l, e.line.ROOT) : (a = k("#" + r[o][0].tId + e.id.SWITCH), 
                        i.replaceSwitchClass(r[o][0], a, e.line.ROOTS), i.replaceSwitchClass(c, l, e.line.BOTTOM)) : i.replaceSwitchClass(c, l, e.line.BOTTOM), 
                        d.removeClass(e.line.LINE);
                    }
                } else r.isParent = !1, r.open = !1, d = k("#" + r.tId + e.id.UL), l = k("#" + r.tId + e.id.SWITCH), 
                s = k("#" + r.tId + e.id.ICON), i.replaceSwitchClass(r, l, e.folder.DOCU), i.replaceIcoClass(r, s, e.folder.DOCU), 
                d.css("display", "none");
            }
        },
        replaceIcoClass: function(t, n, a) {
            if (n && !t.isAjaxing && void 0 != (t = n.attr("class"))) {
                switch (t = t.split("_"), a) {
                  case e.folder.OPEN:
                  case e.folder.CLOSE:
                  case e.folder.DOCU:
                    t[t.length - 1] = a;
                }
                n.attr("class", t.join("_"));
            }
        },
        replaceSwitchClass: function(t, n, a) {
            if (n) {
                var o = n.attr("class");
                if (void 0 != o) {
                    switch (o = o.split("_"), a) {
                      case e.line.ROOT:
                      case e.line.ROOTS:
                      case e.line.CENTER:
                      case e.line.BOTTOM:
                      case e.line.NOLINE:
                        o[0] = i.makeNodeLineClassEx(t) + a;
                        break;

                      case e.folder.OPEN:
                      case e.folder.CLOSE:
                      case e.folder.DOCU:
                        o[1] = a;
                    }
                    n.attr("class", o.join("_")), a !== e.folder.DOCU ? n.removeAttr("disabled") : n.attr("disabled", "disabled");
                }
            }
        },
        selectNode: function(t, n, a) {
            a || i.cancelPreSelectedNode(t), k("#" + n.tId + e.id.A).addClass(e.node.CURSELECTED), 
            h.addSelectedNode(t, n);
        },
        setNodeFontCss: function(t, n) {
            var a = k("#" + n.tId + e.id.A), o = i.makeNodeFontCss(t, n);
            o && a.css(o);
        },
        setNodeLineIcos: function(t, n) {
            if (n) {
                var a = k("#" + n.tId + e.id.SWITCH), o = k("#" + n.tId + e.id.UL), r = k("#" + n.tId + e.id.ICON), d = i.makeUlLineClass(t, n);
                0 == d.length ? o.removeClass(e.line.LINE) : o.addClass(d), a.attr("class", i.makeNodeLineClass(t, n)), 
                n.isParent ? a.removeAttr("disabled") : a.attr("disabled", "disabled"), r.removeAttr("style"), 
                r.attr("style", i.makeNodeIcoStyle(t, n)), r.attr("class", i.makeNodeIcoClass(t, n));
            }
        },
        setNodeName: function(t, n) {
            var a = h.getNodeTitle(t, n), o = k("#" + n.tId + e.id.SPAN);
            o.empty(), t.view.nameIsHTML ? o.html(h.getNodeName(t, n)) : o.text(h.getNodeName(t, n)), 
            j.apply(t.view.showTitle, [ t.treeId, n ], t.view.showTitle) && k("#" + n.tId + e.id.A).attr("title", a || "");
        },
        setNodeTarget: function(t) {
            k("#" + t.tId + e.id.A).attr("target", i.makeNodeTarget(t));
        },
        setNodeUrl: function(t, n) {
            var a = k("#" + n.tId + e.id.A), o = i.makeNodeUrl(t, n);
            null == o || 0 == o.length ? a.removeAttr("href") : a.attr("href", o);
        },
        switchNode: function(e, t) {
            t.open || !j.canAsync(e, t) ? i.expandCollapseNode(e, t, !t.open) : e.async.enable ? i.asyncNode(e, t) || i.expandCollapseNode(e, t, !t.open) : t && i.expandCollapseNode(e, t, !t.open);
        }
    };
    k.fn.zTree = {
        consts: {
            event: {
                NODECREATED: "ztree_nodeCreated",
                CLICK: "ztree_click",
                EXPAND: "ztree_expand",
                COLLAPSE: "ztree_collapse",
                ASYNC_SUCCESS: "ztree_async_success",
                ASYNC_ERROR: "ztree_async_error"
            },
            id: {
                A: "_a",
                ICON: "_ico",
                SPAN: "_span",
                SWITCH: "_switch",
                UL: "_ul"
            },
            line: {
                ROOT: "root",
                ROOTS: "roots",
                CENTER: "center",
                BOTTOM: "bottom",
                NOLINE: "noline",
                LINE: "line"
            },
            folder: {
                OPEN: "open",
                CLOSE: "close",
                DOCU: "docu"
            },
            node: {
                CURSELECTED: "curSelectedNode"
            }
        },
        _z: {
            tools: j,
            view: i,
            event: m,
            data: h
        },
        getZTreeObj: function(e) {
            return (e = h.getZTreeTools(e)) ? e : null;
        },
        destroy: function(e) {
            if (e && e.length > 0) i.destroy(h.getSetting(e)); else for (var t in r) i.destroy(r[t]);
        },
        init: function(t, n, a) {
            var o = j.clone(M);
            return k.extend(!0, o, n), o.treeId = t.attr("id"), o.treeObj = t, o.treeObj.empty(), 
            r[o.treeId] = o, void 0 === document.body.style.maxHeight && (o.view.expandSpeed = ""), 
            h.initRoot(o), t = h.getRoot(o), n = o.data.key.children, a = a ? j.clone(j.isArray(a) ? a : [ a ]) : [], 
            t[n] = o.data.simpleData.enable ? h.transformTozTreeFormat(o, a) : a, h.initCache(o), 
            m.unbindTree(o), m.bindTree(o), m.unbindEvent(o), m.bindEvent(o), a = {
                setting: o,
                addNodes: function(e, t, n) {
                    function a() {
                        i.addNodes(o, e, r, 1 == n);
                    }
                    if (!t) return null;
                    if (e || (e = null), e && !e.isParent && o.data.keep.leaf) return null;
                    var r = j.clone(j.isArray(t) ? t : [ t ]);
                    return j.canAsync(o, e) ? i.asyncNode(o, e, n, a) : a(), r;
                },
                cancelSelectedNode: function(e) {
                    i.cancelPreSelectedNode(this.setting, e);
                },
                destroy: function() {
                    i.destroy(this.setting);
                },
                expandAll: function(e) {
                    return e = !!e, i.expandCollapseSonNode(this.setting, null, e, !0), e;
                },
                expandNode: function(e, t, n, a, r) {
                    if (!e || !e.isParent) return null;
                    if (!0 !== t && !1 !== t && (t = !e.open), (r = !!r) && t && 0 == j.apply(o.callback.beforeExpand, [ o.treeId, e ], !0)) return null;
                    if (r && !t && 0 == j.apply(o.callback.beforeCollapse, [ o.treeId, e ], !0)) return null;
                    if (t && e.parentTId && i.expandCollapseParentNode(this.setting, e.getParentNode(), t, !1), 
                    t === e.open && !n) return null;
                    if (h.getRoot(o).expandTriggerFlag = r, n) i.expandCollapseSonNode(this.setting, e, t, !0, function() {
                        if (!1 !== a) try {
                            k("#" + e.tId).focus().blur();
                        } catch (e) {}
                    }); else if (e.open = !t, i.switchNode(this.setting, e), !1 !== a) try {
                        k("#" + e.tId).focus().blur();
                    } catch (e) {}
                    return t;
                },
                getNodes: function() {
                    return h.getNodes(this.setting);
                },
                getNodeByParam: function(e, t, n) {
                    return e ? h.getNodeByParam(this.setting, n ? n[this.setting.data.key.children] : h.getNodes(this.setting), e, t) : null;
                },
                getNodeByTId: function(e) {
                    return h.getNodeCache(this.setting, e);
                },
                getNodesByParam: function(e, t, n) {
                    return e ? h.getNodesByParam(this.setting, n ? n[this.setting.data.key.children] : h.getNodes(this.setting), e, t) : null;
                },
                getNodesByParamFuzzy: function(e, t, n) {
                    return e ? h.getNodesByParamFuzzy(this.setting, n ? n[this.setting.data.key.children] : h.getNodes(this.setting), e, t) : null;
                },
                getNodesByFilter: function(e, t, n, a) {
                    return t = !!t, e && "function" == typeof e ? h.getNodesByFilter(this.setting, n ? n[this.setting.data.key.children] : h.getNodes(this.setting), e, t, a) : t ? null : [];
                },
                getNodeIndex: function(e) {
                    if (!e) return null;
                    for (var t = o.data.key.children, n = e.parentTId ? e.getParentNode() : h.getRoot(this.setting), a = 0, r = n[t].length; a < r; a++) if (n[t][a] == e) return a;
                    return -1;
                },
                getSelectedNodes: function() {
                    for (var e = [], t = h.getRoot(this.setting).curSelectedList, n = 0, a = t.length; n < a; n++) e.push(t[n]);
                    return e;
                },
                isSelectedNode: function(e) {
                    return h.isSelectedNode(this.setting, e);
                },
                reAsyncChildNodes: function(t, n, a) {
                    if (this.setting.async.enable) {
                        var r = !t;
                        if (r && (t = h.getRoot(this.setting)), "refresh" == n) {
                            for (var d = 0, l = t[n = this.setting.data.key.children] ? t[n].length : 0; d < l; d++) h.removeNodeCache(o, t[n][d]);
                            h.removeSelectedNode(o), t[n] = [], r ? this.setting.treeObj.empty() : k("#" + t.tId + e.id.UL).empty();
                        }
                        i.asyncNode(this.setting, r ? null : t, !!a);
                    }
                },
                refresh: function() {
                    this.setting.treeObj.empty();
                    var e = h.getRoot(this.setting), t = e[this.setting.data.key.children];
                    h.initRoot(this.setting), e[this.setting.data.key.children] = t, h.initCache(this.setting), 
                    i.createNodes(this.setting, 0, e[this.setting.data.key.children]);
                },
                removeChildNodes: function(e) {
                    if (!e) return null;
                    var t = e[o.data.key.children];
                    return i.removeChildNodes(o, e), t || null;
                },
                removeNode: function(t, n) {
                    t && ((n = !!n) && 0 == j.apply(o.callback.beforeRemove, [ o.treeId, t ], !0) || (i.removeNode(o, t), 
                    n && this.setting.treeObj.trigger(e.event.REMOVE, [ o.treeId, t ])));
                },
                selectNode: function(e, t) {
                    if (e && j.uCanDo(this.setting)) {
                        if (t = o.view.selectedMulti && t, e.parentTId) i.expandCollapseParentNode(this.setting, e.getParentNode(), !0, !1, function() {
                            try {
                                k("#" + e.tId).focus().blur();
                            } catch (e) {}
                        }); else try {
                            k("#" + e.tId).focus().blur();
                        } catch (e) {}
                        i.selectNode(this.setting, e, t);
                    }
                },
                transformTozTreeNodes: function(e) {
                    return h.transformTozTreeFormat(this.setting, e);
                },
                transformToArray: function(e) {
                    return h.transformToArrayFormat(this.setting, e);
                },
                updateNode: function(e) {
                    e && k("#" + e.tId).get(0) && j.uCanDo(this.setting) && (i.setNodeName(this.setting, e), 
                    i.setNodeTarget(e), i.setNodeUrl(this.setting, e), i.setNodeLineIcos(this.setting, e), 
                    i.setNodeFontCss(this.setting, e));
                }
            }, t.treeTools = a, h.setZTreeTools(o, a), t[n] && t[n].length > 0 ? i.createNodes(o, 0, t[n]) : o.async.enable && o.async.url && "" !== o.async.url && i.asyncNode(o), 
            a;
        }
    };
    var N = k.fn.zTree, e = N.consts;
}(jQuery), function(e) {
    var t, n, a, o = {
        event: {
            CHECK: "ztree_check"
        },
        id: {
            CHECK: "_check"
        },
        checkbox: {
            STYLE: "checkbox",
            DEFAULT: "chk",
            DISABLED: "disable",
            FALSE: "false",
            TRUE: "true",
            FULL: "full",
            PART: "part",
            FOCUS: "focus"
        },
        radio: {
            STYLE: "radio",
            TYPE_ALL: "all",
            TYPE_LEVEL: "level"
        }
    }, r = {
        check: {
            enable: !1,
            autoCheckTrigger: !1,
            chkStyle: o.checkbox.STYLE,
            nocheckInherit: !1,
            chkDisabledInherit: !1,
            radioType: o.radio.TYPE_LEVEL,
            chkboxType: {
                Y: "ps",
                N: "ps"
            }
        },
        data: {
            key: {
                checked: "checked"
            }
        },
        callback: {
            beforeCheck: null,
            onCheck: null
        }
    };
    t = function(t, n) {
        if (!0 === n.chkDisabled) return !1;
        var a = s.getSetting(t.data.treeId), o = a.data.key.checked;
        return 0 == d.apply(a.callback.beforeCheck, [ a.treeId, n ], !0) || (n[o] = !n[o], 
        l.checkNodeRelation(a, n), o = e("#" + n.tId + i.id.CHECK), l.setChkClass(a, o, n), 
        l.repairParentChkClassWithSelf(a, n), a.treeObj.trigger(i.event.CHECK, [ t, a.treeId, n ]), 
        !0);
    }, n = function(t, n) {
        if (!0 === n.chkDisabled) return !1;
        var a = s.getSetting(t.data.treeId), o = e("#" + n.tId + i.id.CHECK);
        return n.check_Focus = !0, l.setChkClass(a, o, n), !0;
    }, a = function(t, n) {
        if (!0 === n.chkDisabled) return !1;
        var a = s.getSetting(t.data.treeId), o = e("#" + n.tId + i.id.CHECK);
        return n.check_Focus = !1, l.setChkClass(a, o, n), !0;
    }, e.extend(!0, e.fn.zTree.consts, o), e.extend(!0, e.fn.zTree._z, {
        tools: {},
        view: {
            checkNodeRelation: function(t, n) {
                var a, o, r, d = t.data.key.children, c = t.data.key.checked;
                if (a = i.radio, t.check.chkStyle == a.STYLE) {
                    var u = s.getRadioCheckedList(t);
                    if (n[c]) if (t.check.radioType == a.TYPE_ALL) {
                        for (o = u.length - 1; o >= 0; o--) (a = u[o])[c] = !1, u.splice(o, 1), l.setChkClass(t, e("#" + a.tId + i.id.CHECK), a), 
                        a.parentTId != n.parentTId && l.repairParentChkClassWithSelf(t, a);
                        u.push(n);
                    } else for (o = 0, r = (u = n.parentTId ? n.getParentNode() : s.getRoot(t))[d].length; o < r; o++) (a = u[d][o])[c] && a != n && (a[c] = !1, 
                    l.setChkClass(t, e("#" + a.tId + i.id.CHECK), a)); else if (t.check.radioType == a.TYPE_ALL) for (o = 0, 
                    r = u.length; o < r; o++) if (n == u[o]) {
                        u.splice(o, 1);
                        break;
                    }
                } else n[c] && (!n[d] || 0 == n[d].length || t.check.chkboxType.Y.indexOf("s") > -1) && l.setSonNodeCheckBox(t, n, !0), 
                !n[c] && (!n[d] || 0 == n[d].length || t.check.chkboxType.N.indexOf("s") > -1) && l.setSonNodeCheckBox(t, n, !1), 
                n[c] && t.check.chkboxType.Y.indexOf("p") > -1 && l.setParentNodeCheckBox(t, n, !0), 
                !n[c] && t.check.chkboxType.N.indexOf("p") > -1 && l.setParentNodeCheckBox(t, n, !1);
            },
            makeChkClass: function(e, t) {
                var n = e.data.key.checked, a = i.checkbox, o = i.radio, r = "", r = !0 === t.chkDisabled ? a.DISABLED : t.halfCheck ? a.PART : e.check.chkStyle == o.STYLE ? t.check_Child_State < 1 ? a.FULL : a.PART : t[n] ? 2 === t.check_Child_State || -1 === t.check_Child_State ? a.FULL : a.PART : t.check_Child_State < 1 ? a.FULL : a.PART, n = e.check.chkStyle + "_" + (t[n] ? a.TRUE : a.FALSE) + "_" + r, n = t.check_Focus && !0 !== t.chkDisabled ? n + "_" + a.FOCUS : n;
                return "button " + a.DEFAULT + " " + n;
            },
            repairAllChk: function(e, t) {
                if (e.check.enable && e.check.chkStyle === i.checkbox.STYLE) for (var n = e.data.key.checked, a = e.data.key.children, o = s.getRoot(e), r = 0, d = o[a].length; r < d; r++) {
                    var c = o[a][r];
                    !0 !== c.nocheck && !0 !== c.chkDisabled && (c[n] = t), l.setSonNodeCheckBox(e, c, t);
                }
            },
            repairChkClass: function(t, n) {
                if (n && (s.makeChkFlag(t, n), !0 !== n.nocheck)) {
                    var a = e("#" + n.tId + i.id.CHECK);
                    l.setChkClass(t, a, n);
                }
            },
            repairParentChkClass: function(e, t) {
                if (t && t.parentTId) {
                    var n = t.getParentNode();
                    l.repairChkClass(e, n), l.repairParentChkClass(e, n);
                }
            },
            repairParentChkClassWithSelf: function(e, t) {
                if (t) {
                    var n = e.data.key.children;
                    t[n] && t[n].length > 0 ? l.repairParentChkClass(e, t[n][0]) : l.repairParentChkClass(e, t);
                }
            },
            repairSonChkDisabled: function(e, t, n, a) {
                if (t) {
                    var o = e.data.key.children;
                    if (t.chkDisabled != n && (t.chkDisabled = n), l.repairChkClass(e, t), t[o] && a) for (var r = 0, d = t[o].length; r < d; r++) l.repairSonChkDisabled(e, t[o][r], n, a);
                }
            },
            repairParentChkDisabled: function(e, t, n, a) {
                t && (t.chkDisabled != n && a && (t.chkDisabled = n), l.repairChkClass(e, t), l.repairParentChkDisabled(e, t.getParentNode(), n, a));
            },
            setChkClass: function(e, t, n) {
                t && (!0 === n.nocheck ? t.hide() : t.show(), t.removeClass(), t.addClass(l.makeChkClass(e, n)));
            },
            setParentNodeCheckBox: function(t, n, a, o) {
                var r = t.data.key.children, d = t.data.key.checked, c = e("#" + n.tId + i.id.CHECK);
                if (o || (o = n), s.makeChkFlag(t, n), !0 !== n.nocheck && !0 !== n.chkDisabled && (n[d] = a, 
                l.setChkClass(t, c, n), t.check.autoCheckTrigger && n != o && t.treeObj.trigger(i.event.CHECK, [ null, t.treeId, n ])), 
                n.parentTId) {
                    if (c = !0, !a) for (var r = n.getParentNode()[r], u = 0, h = r.length; u < h; u++) if (!0 !== r[u].nocheck && !0 !== r[u].chkDisabled && r[u][d] || (!0 === r[u].nocheck || !0 === r[u].chkDisabled) && r[u].check_Child_State > 0) {
                        c = !1;
                        break;
                    }
                    c && l.setParentNodeCheckBox(t, n.getParentNode(), a, o);
                }
            },
            setSonNodeCheckBox: function(t, n, a, o) {
                if (n) {
                    var r = t.data.key.children, d = t.data.key.checked, c = e("#" + n.tId + i.id.CHECK);
                    o || (o = n);
                    var u = !1;
                    if (n[r]) for (var h = 0, p = n[r].length; h < p && !0 !== n.chkDisabled; h++) {
                        var f = n[r][h];
                        l.setSonNodeCheckBox(t, f, a, o), !0 === f.chkDisabled && (u = !0);
                    }
                    n != s.getRoot(t) && !0 !== n.chkDisabled && (u && !0 !== n.nocheck && s.makeChkFlag(t, n), 
                    !0 !== n.nocheck && !0 !== n.chkDisabled ? (n[d] = a, u || (n.check_Child_State = n[r] && n[r].length > 0 ? a ? 2 : 0 : -1)) : n.check_Child_State = -1, 
                    l.setChkClass(t, c, n), t.check.autoCheckTrigger && n != o && !0 !== n.nocheck && !0 !== n.chkDisabled && t.treeObj.trigger(i.event.CHECK, [ null, t.treeId, n ]));
                }
            }
        },
        event: {},
        data: {
            getRadioCheckedList: function(e) {
                for (var t = s.getRoot(e).radioCheckedList, n = 0, a = t.length; n < a; n++) s.getNodeCache(e, t[n].tId) || (t.splice(n, 1), 
                n--, a--);
                return t;
            },
            getCheckStatus: function(e, t) {
                if (!e.check.enable || t.nocheck || t.chkDisabled) return null;
                var n = e.data.key.checked;
                return {
                    checked: t[n],
                    half: t.halfCheck ? t.halfCheck : e.check.chkStyle == i.radio.STYLE ? 2 === t.check_Child_State : t[n] ? t.check_Child_State > -1 && t.check_Child_State < 2 : t.check_Child_State > 0
                };
            },
            getTreeCheckedNodes: function(e, t, n, a) {
                if (!t) return [];
                for (var o = e.data.key.children, r = e.data.key.checked, d = n && e.check.chkStyle == i.radio.STYLE && e.check.radioType == i.radio.TYPE_ALL, a = a || [], l = 0, c = t.length; l < c && (!0 === t[l].nocheck || !0 === t[l].chkDisabled || t[l][r] != n || (a.push(t[l]), 
                !d)) && (s.getTreeCheckedNodes(e, t[l][o], n, a), !(d && a.length > 0)); l++) ;
                return a;
            },
            getTreeChangeCheckedNodes: function(e, t, n) {
                if (!t) return [];
                for (var a = e.data.key.children, o = e.data.key.checked, n = n || [], r = 0, d = t.length; r < d; r++) !0 !== t[r].nocheck && !0 !== t[r].chkDisabled && t[r][o] != t[r].checkedOld && n.push(t[r]), 
                s.getTreeChangeCheckedNodes(e, t[r][a], n);
                return n;
            },
            makeChkFlag: function(e, t) {
                if (t) {
                    var n = e.data.key.children, a = e.data.key.checked, o = -1;
                    if (t[n]) for (var r = 0, d = t[n].length; r < d; r++) {
                        var l = t[n][r], s = -1;
                        if (e.check.chkStyle == i.radio.STYLE) {
                            if (2 == (s = !0 === l.nocheck || !0 === l.chkDisabled ? l.check_Child_State : !0 === l.halfCheck ? 2 : l[a] ? 2 : l.check_Child_State > 0 ? 2 : 0)) {
                                o = 2;
                                break;
                            }
                            0 == s && (o = 0);
                        } else if (e.check.chkStyle == i.checkbox.STYLE) {
                            if (1 === (s = !0 === l.nocheck || !0 === l.chkDisabled ? l.check_Child_State : !0 === l.halfCheck ? 1 : l[a] ? -1 === l.check_Child_State || 2 === l.check_Child_State ? 2 : 1 : l.check_Child_State > 0 ? 1 : 0)) {
                                o = 1;
                                break;
                            }
                            if (2 === s && o > -1 && r > 0 && s !== o) {
                                o = 1;
                                break;
                            }
                            if (2 === o && s > -1 && s < 2) {
                                o = 1;
                                break;
                            }
                            s > -1 && (o = s);
                        }
                    }
                    t.check_Child_State = o;
                }
            }
        }
    });
    var d = (o = e.fn.zTree)._z.tools, i = o.consts, l = o._z.view, s = o._z.data;
    s.exSetting(r), s.addInitBind(function(e) {
        e.treeObj.bind(i.event.CHECK, function(t, n, a, o) {
            d.apply(e.callback.onCheck, [ n || t, a, o ]);
        });
    }), s.addInitUnBind(function(e) {
        e.treeObj.unbind(i.event.CHECK);
    }), s.addInitCache(function() {}), s.addInitNode(function(e, t, n, a) {
        n && (t = e.data.key.checked, "string" == typeof n[t] && (n[t] = d.eqs(n[t], "true")), 
        n[t] = !!n[t], n.checkedOld = n[t], "string" == typeof n.nocheck && (n.nocheck = d.eqs(n.nocheck, "true")), 
        n.nocheck = !!n.nocheck || e.check.nocheckInherit && a && !!a.nocheck, "string" == typeof n.chkDisabled && (n.chkDisabled = d.eqs(n.chkDisabled, "true")), 
        n.chkDisabled = !!n.chkDisabled || e.check.chkDisabledInherit && a && !!a.chkDisabled, 
        "string" == typeof n.halfCheck && (n.halfCheck = d.eqs(n.halfCheck, "true")), n.halfCheck = !!n.halfCheck, 
        n.check_Child_State = -1, n.check_Focus = !1, n.getCheckStatus = function() {
            return s.getCheckStatus(e, n);
        });
    }), s.addInitProxy(function(e) {
        var o = e.target, r = s.getSetting(e.data.treeId), l = "", c = null, u = "", h = null;
        if (d.eqs(e.type, "mouseover") ? r.check.enable && d.eqs(o.tagName, "span") && null !== o.getAttribute("treeNode" + i.id.CHECK) && (l = o.parentNode.id, 
        u = "mouseoverCheck") : d.eqs(e.type, "mouseout") ? r.check.enable && d.eqs(o.tagName, "span") && null !== o.getAttribute("treeNode" + i.id.CHECK) && (l = o.parentNode.id, 
        u = "mouseoutCheck") : d.eqs(e.type, "click") && r.check.enable && d.eqs(o.tagName, "span") && null !== o.getAttribute("treeNode" + i.id.CHECK) && (l = o.parentNode.id, 
        u = "checkNode"), l.length > 0) switch (c = s.getNodeCache(r, l), u) {
          case "checkNode":
            h = t;
            break;

          case "mouseoverCheck":
            h = n;
            break;

          case "mouseoutCheck":
            h = a;
        }
        return {
            stop: !1,
            node: c,
            nodeEventType: u,
            nodeEventCallback: h,
            treeEventType: "",
            treeEventCallback: null
        };
    }), s.addInitRoot(function(e) {
        s.getRoot(e).radioCheckedList = [];
    }), s.addBeforeA(function(e, t, n) {
        var a = e.data.key.checked;
        e.check.enable && (s.makeChkFlag(e, t), e.check.chkStyle == i.radio.STYLE && e.check.radioType == i.radio.TYPE_ALL && t[a] && s.getRoot(e).radioCheckedList.push(t), 
        n.push("<span ID='", t.tId, i.id.CHECK, "' class='", l.makeChkClass(e, t), "' treeNode", i.id.CHECK, !0 === t.nocheck ? " style='display:none;'" : "", "></span>"));
    }), s.addZTreeTools(function(t, n) {
        n.checkNode = function(n, a, o, r) {
            var s = this.setting.data.key.checked;
            !0 === n.chkDisabled || (!0 !== a && !1 !== a && (a = !n[s]), r = !!r, n[s] === a && !o || r && 0 == d.apply(this.setting.callback.beforeCheck, [ this.setting.treeId, n ], !0) || !d.uCanDo(this.setting) || !this.setting.check.enable || !0 === n.nocheck) || (n[s] = a, 
            a = e("#" + n.tId + i.id.CHECK), (o || this.setting.check.chkStyle === i.radio.STYLE) && l.checkNodeRelation(this.setting, n), 
            l.setChkClass(this.setting, a, n), l.repairParentChkClassWithSelf(this.setting, n), 
            r && t.treeObj.trigger(i.event.CHECK, [ null, t.treeId, n ]));
        }, n.checkAllNodes = function(e) {
            l.repairAllChk(this.setting, !!e);
        }, n.getCheckedNodes = function(e) {
            var n = this.setting.data.key.children;
            return s.getTreeCheckedNodes(this.setting, s.getRoot(t)[n], !1 !== e);
        }, n.getChangeCheckedNodes = function() {
            var e = this.setting.data.key.children;
            return s.getTreeChangeCheckedNodes(this.setting, s.getRoot(t)[e]);
        }, n.setChkDisabled = function(e, t, n, a) {
            t = !!t, n = !!n, l.repairSonChkDisabled(this.setting, e, t, !!a), l.repairParentChkDisabled(this.setting, e.getParentNode(), t, n);
        };
        var a = n.updateNode;
        n.updateNode = function(t, o) {
            if (a && a.apply(n, arguments), t && this.setting.check.enable && e("#" + t.tId).get(0) && d.uCanDo(this.setting)) {
                var r = e("#" + t.tId + i.id.CHECK);
                (1 == o || this.setting.check.chkStyle === i.radio.STYLE) && l.checkNodeRelation(this.setting, t), 
                l.setChkClass(this.setting, r, t), l.repairParentChkClassWithSelf(this.setting, t);
            }
        };
    });
    var c = l.createNodes;
    l.createNodes = function(e, t, n, a) {
        c && c.apply(l, arguments), n && l.repairParentChkClassWithSelf(e, a);
    };
    var u = l.removeNode;
    l.removeNode = function(e, t) {
        var n = t.getParentNode();
        u && u.apply(l, arguments), t && n && (l.repairChkClass(e, n), l.repairParentChkClass(e, n));
    };
    var h = l.appendNodes;
    l.appendNodes = function(e, t, n, a, o, r) {
        var d = "";
        return h && (d = h.apply(l, arguments)), a && s.makeChkFlag(e, a), d;
    };
}(jQuery), function(e) {
    var t = {
        event: {
            DRAG: "ztree_drag",
            DROP: "ztree_drop",
            REMOVE: "ztree_remove",
            RENAME: "ztree_rename"
        },
        id: {
            EDIT: "_edit",
            INPUT: "_input",
            REMOVE: "_remove"
        },
        move: {
            TYPE_INNER: "inner",
            TYPE_PREV: "prev",
            TYPE_NEXT: "next"
        },
        node: {
            CURSELECTED_EDIT: "curSelectedNode_Edit",
            TMPTARGET_TREE: "tmpTargetzTree",
            TMPTARGET_NODE: "tmpTargetNode"
        }
    }, n = {
        onHoverOverNode: function(e, t) {
            var a = i.getSetting(e.data.treeId), o = i.getRoot(a);
            o.curHoverNode != t && n.onHoverOutNode(e), o.curHoverNode = t, d.addHoverDom(a, t);
        },
        onHoverOutNode: function(e) {
            var e = i.getSetting(e.data.treeId), t = i.getRoot(e);
            t.curHoverNode && !i.isSelectedNode(e, t.curHoverNode) && (d.removeTreeDom(e, t.curHoverNode), 
            t.curHoverNode = null);
        },
        onMousedownNode: function(n, a) {
            function l(n) {
                if (0 == f.dragFlag && Math.abs(O - n.clientX) < p.edit.drag.minMoveSize && Math.abs(L - n.clientY) < p.edit.drag.minMoveSize) return !0;
                var a, l, c, u, h;
                if (h = p.data.key.children, e("body").css("cursor", "pointer"), 0 == f.dragFlag) {
                    if (0 == o.apply(p.callback.beforeDrag, [ p.treeId, k ], !0)) return s(n), !0;
                    for (a = 0, l = k.length; a < l; a++) 0 == a && (f.dragNodeShowBefore = []), (c = k[a]).isParent && c.open ? (d.expandCollapseNode(p, c, !c.open), 
                    f.dragNodeShowBefore[c.tId] = !0) : f.dragNodeShowBefore[c.tId] = !1;
                    if (f.dragFlag = 1, f.showHoverDom = !1, o.showIfameMask(p, !0), c = !0, u = -1, 
                    k.length > 1) {
                        x = k[0].parentTId ? k[0].getParentNode()[h] : i.getNodes(p);
                        for (h = [], a = 0, l = x.length; a < l; a++) if (void 0 !== f.dragNodeShowBefore[x[a].tId] && (c && u > -1 && u + 1 !== a && (c = !1), 
                        h.push(x[a]), u = a), k.length === h.length) {
                            k = h;
                            break;
                        }
                    }
                    for (c && (y = k[0].getPreNode(), I = k[k.length - 1].getNextNode()), v = e("<ul class='zTreeDragUL'></ul>"), 
                    a = 0, l = k.length; a < l; a++) if (c = k[a], c.editNameFlag = !1, d.selectNode(p, c, a > 0), 
                    d.removeTreeDom(p, c), (u = e("<li id='" + c.tId + "_tmp'></li>")).append(e("#" + c.tId + r.id.A).clone()), 
                    u.css("padding", "0"), u.children("#" + c.tId + r.id.A).removeClass(r.node.CURSELECTED), 
                    v.append(u), a == p.edit.drag.maxShowNodeNum - 1) {
                        u = e("<li id='" + c.tId + "_moretmp'><a>  ...  </a></li>"), v.append(u);
                        break;
                    }
                    v.attr("id", k[0].tId + r.id.UL + "_tmp"), v.addClass(p.treeObj.attr("class")), 
                    v.appendTo("body"), (C = e("<span class='tmpzTreeMove_arrow'></span>")).attr("id", "zTreeMove_arrow_tmp"), 
                    C.appendTo("body"), p.treeObj.trigger(r.event.DRAG, [ n, p.treeId, k ]);
                }
                if (1 == f.dragFlag) {
                    m && C.attr("id") == n.target.id && R && n.clientX + b.scrollLeft() + 2 > e("#" + R + r.id.A, m).offset().left ? (c = e("#" + R + r.id.A, m), 
                    n.target = c.length > 0 ? c.get(0) : n.target) : m && (m.removeClass(r.node.TMPTARGET_TREE), 
                    R && e("#" + R + r.id.A, m).removeClass(r.node.TMPTARGET_NODE + "_" + r.move.TYPE_PREV).removeClass(r.node.TMPTARGET_NODE + "_" + t.move.TYPE_NEXT).removeClass(r.node.TMPTARGET_NODE + "_" + t.move.TYPE_INNER)), 
                    R = m = null, T = !1, E = p, c = i.getSettings();
                    for (var g in c) c[g].treeId && c[g].edit.enable && c[g].treeId != p.treeId && (n.target.id == c[g].treeId || e(n.target).parents("#" + c[g].treeId).length > 0) && (T = !0, 
                    E = c[g]);
                    g = b.scrollTop(), u = b.scrollLeft(), h = E.treeObj.offset(), a = E.treeObj.get(0).scrollHeight, 
                    c = E.treeObj.get(0).scrollWidth, l = n.clientY + g - h.top;
                    var N = E.treeObj.height() + h.top - n.clientY - g, w = n.clientX + u - h.left, A = E.treeObj.width() + h.left - n.clientX - u;
                    h = l < p.edit.drag.borderMax && l > p.edit.drag.borderMin;
                    var x = N < p.edit.drag.borderMax && N > p.edit.drag.borderMin, j = w < p.edit.drag.borderMax && w > p.edit.drag.borderMin, M = A < p.edit.drag.borderMax && A > p.edit.drag.borderMin, N = l > p.edit.drag.borderMin && N > p.edit.drag.borderMin && w > p.edit.drag.borderMin && A > p.edit.drag.borderMin, w = h && E.treeObj.scrollTop() <= 0, A = x && E.treeObj.scrollTop() + E.treeObj.height() + 10 >= a, F = j && E.treeObj.scrollLeft() <= 0, U = M && E.treeObj.scrollLeft() + E.treeObj.width() + 10 >= c;
                    if (n.target.id && E.treeObj.find("#" + n.target.id).length > 0) {
                        for (var B = n.target; B && B.tagName && !o.eqs(B.tagName, "li") && B.id != E.treeId; ) B = B.parentNode;
                        var Y = !0;
                        for (a = 0, l = k.length; a < l; a++) {
                            if (c = k[a], B.id === c.tId) {
                                Y = !1;
                                break;
                            }
                            if (e("#" + c.tId).find("#" + B.id).length > 0) {
                                Y = !1;
                                break;
                            }
                        }
                        Y && n.target.id && (n.target.id == B.id + r.id.A || e(n.target).parents("#" + B.id + r.id.A).length > 0) && (m = e(B), 
                        R = B.id);
                    }
                    if (c = k[0], N && (n.target.id == E.treeId || e(n.target).parents("#" + E.treeId).length > 0) && (!m && (n.target.id == E.treeId || w || A || F || U) && (T || !T && c.parentTId) && (m = E.treeObj), 
                    h ? E.treeObj.scrollTop(E.treeObj.scrollTop() - 10) : x && E.treeObj.scrollTop(E.treeObj.scrollTop() + 10), 
                    j ? E.treeObj.scrollLeft(E.treeObj.scrollLeft() - 10) : M && E.treeObj.scrollLeft(E.treeObj.scrollLeft() + 10), 
                    m && m != E.treeObj && m.offset().left < E.treeObj.offset().left && E.treeObj.scrollLeft(E.treeObj.scrollLeft() + m.offset().left - E.treeObj.offset().left)), 
                    v.css({
                        top: n.clientY + g + 3 + "px",
                        left: n.clientX + u + 3 + "px"
                    }), h = a = 0, m && m.attr("id") != E.treeId) {
                        var z = null == R ? null : i.getNodeCache(E, R);
                        l = n.ctrlKey && p.edit.drag.isMove && p.edit.drag.isCopy || !p.edit.drag.isMove && p.edit.drag.isCopy, 
                        a = !(!y || R !== y.tId), h = !(!I || R !== I.tId), u = c.parentTId && c.parentTId == R, 
                        c = (l || !h) && o.apply(E.edit.drag.prev, [ E.treeId, k, z ], !!E.edit.drag.prev), 
                        a = (l || !a) && o.apply(E.edit.drag.next, [ E.treeId, k, z ], !!E.edit.drag.next), 
                        M = (l || !u) && !(E.data.keep.leaf && !z.isParent) && o.apply(E.edit.drag.inner, [ E.treeId, k, z ], !!E.edit.drag.inner), 
                        c || a || M ? (l = e("#" + R + r.id.A, m), h = z.isLastNode ? null : e("#" + z.getNextNode().tId + r.id.A, m.next()), 
                        x = l.offset().top, u = l.offset().left, j = c ? M ? .25 : a ? .5 : 1 : -1, M = a ? M ? .75 : c ? .5 : 0 : -1, 
                        n = (n.clientY + g - x) / l.height(), (1 == j || n <= j && n >= -.2) && c ? (a = 1 - C.width(), 
                        h = x - C.height() / 2, D = r.move.TYPE_PREV) : (0 == M || n >= M && n <= 1.2) && a ? (a = 1 - C.width(), 
                        h = null == h || z.isParent && z.open ? x + l.height() - C.height() / 2 : h.offset().top - C.height() / 2, 
                        D = r.move.TYPE_NEXT) : (a = 5 - C.width(), h = x, D = r.move.TYPE_INNER), C.css({
                            display: "block",
                            top: h + "px",
                            left: u + a + "px"
                        }), l.addClass(r.node.TMPTARGET_NODE + "_" + D), S == R && P == D || (_ = new Date().getTime()), 
                        z && z.isParent && D == r.move.TYPE_INNER && (n = !0, window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId !== z.tId ? (clearTimeout(window.zTreeMoveTimer), 
                        window.zTreeMoveTargetNodeTId = null) : window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId === z.tId && (n = !1), 
                        n) && (window.zTreeMoveTimer = setTimeout(function() {
                            D == r.move.TYPE_INNER && z && z.isParent && !z.open && new Date().getTime() - _ > E.edit.drag.autoOpenTime && o.apply(E.callback.beforeDragOpen, [ E.treeId, z ], !0) && (d.switchNode(E, z), 
                            E.edit.drag.autoExpandTrigger && E.treeObj.trigger(r.event.EXPAND, [ E.treeId, z ]));
                        }, E.edit.drag.autoOpenTime + 50), window.zTreeMoveTargetNodeTId = z.tId)) : (m = null, 
                        R = "", D = r.move.TYPE_INNER, C.css({
                            display: "none"
                        }), window.zTreeMoveTimer && (clearTimeout(window.zTreeMoveTimer), window.zTreeMoveTargetNodeTId = null));
                    } else D = r.move.TYPE_INNER, m && o.apply(E.edit.drag.inner, [ E.treeId, k, null ], !!E.edit.drag.inner) ? m.addClass(r.node.TMPTARGET_TREE) : m = null, 
                    C.css({
                        display: "none"
                    }), window.zTreeMoveTimer && (clearTimeout(window.zTreeMoveTimer), window.zTreeMoveTargetNodeTId = null);
                    S = R, P = D;
                }
                return !1;
            }
            function s(n) {
                if (window.zTreeMoveTimer && (clearTimeout(window.zTreeMoveTimer), window.zTreeMoveTargetNodeTId = null), 
                P = S = null, b.unbind("mousemove", l), b.unbind("mouseup", s), b.unbind("selectstart", c), 
                e("body").css("cursor", "auto"), m && (m.removeClass(r.node.TMPTARGET_TREE), R && e("#" + R + r.id.A, m).removeClass(r.node.TMPTARGET_NODE + "_" + r.move.TYPE_PREV).removeClass(r.node.TMPTARGET_NODE + "_" + t.move.TYPE_NEXT).removeClass(r.node.TMPTARGET_NODE + "_" + t.move.TYPE_INNER)), 
                o.showIfameMask(p, !1), f.showHoverDom = !0, 0 != f.dragFlag) {
                    f.dragFlag = 0;
                    var a, u, h;
                    for (a = 0, u = k.length; a < u; a++) (h = k[a]).isParent && f.dragNodeShowBefore[h.tId] && !h.open && (d.expandCollapseNode(p, h, !h.open), 
                    delete f.dragNodeShowBefore[h.tId]);
                    v && v.remove(), C && C.remove();
                    var g = n.ctrlKey && p.edit.drag.isMove && p.edit.drag.isCopy || !p.edit.drag.isMove && p.edit.drag.isCopy;
                    if (!g && m && R && k[0].parentTId && R == k[0].parentTId && D == r.move.TYPE_INNER && (m = null), 
                    m) {
                        var N = null == R ? null : i.getNodeCache(E, R);
                        if (0 != o.apply(p.callback.beforeDrop, [ E.treeId, k, N, D, g ], !0)) {
                            var y = g ? o.clone(k) : k;
                            a = function() {
                                if (T) {
                                    if (!g) for (var t = 0, a = k.length; t < a; t++) d.removeNode(p, k[t]);
                                    if (D == r.move.TYPE_INNER) d.addNodes(E, N, y); else if (d.addNodes(E, N.getParentNode(), y), 
                                    D == r.move.TYPE_PREV) for (t = 0, a = y.length; t < a; t++) d.moveNode(E, N, y[t], D, !1); else for (t = -1, 
                                    a = y.length - 1; t < a; a--) d.moveNode(E, N, y[a], D, !1);
                                } else if (g && D == r.move.TYPE_INNER) d.addNodes(E, N, y); else if (g && d.addNodes(E, N.getParentNode(), y), 
                                D != r.move.TYPE_NEXT) for (t = 0, a = y.length; t < a; t++) d.moveNode(E, N, y[t], D, !1); else for (t = -1, 
                                a = y.length - 1; t < a; a--) d.moveNode(E, N, y[a], D, !1);
                                for (t = 0, a = y.length; t < a; t++) d.selectNode(E, y[t], t > 0);
                                e("#" + y[0].tId).focus().blur(), p.treeObj.trigger(r.event.DROP, [ n, E.treeId, y, N, D, g ]);
                            }, D == r.move.TYPE_INNER && o.canAsync(E, N) ? d.asyncNode(E, N, !1, a) : a();
                        }
                    } else {
                        for (a = 0, u = k.length; a < u; a++) d.selectNode(E, k[a], a > 0);
                        p.treeObj.trigger(r.event.DROP, [ n, p.treeId, k, null, null, null ]);
                    }
                }
            }
            function c() {
                return !1;
            }
            var u, h, p = i.getSetting(n.data.treeId), f = i.getRoot(p);
            if (2 == n.button || !p.edit.enable || !p.edit.drag.isCopy && !p.edit.drag.isMove) return !0;
            var g = n.target, N = i.getRoot(p).curSelectedList, k = [];
            if (i.isSelectedNode(p, a)) for (u = 0, h = N.length; u < h; u++) {
                if (N[u].editNameFlag && o.eqs(g.tagName, "input") && null !== g.getAttribute("treeNode" + r.id.INPUT)) return !0;
                if (k.push(N[u]), k[0].parentTId !== N[u].parentTId) {
                    k = [ a ];
                    break;
                }
            } else k = [ a ];
            d.editNodeBlur = !0, d.cancelCurEditNode(p, null, !0);
            var v, C, m, y, I, b = e(document), T = !1, E = p, S = null, P = null, R = null, D = r.move.TYPE_INNER, O = n.clientX, L = n.clientY, _ = new Date().getTime();
            return o.uCanDo(p) && b.bind("mousemove", l), b.bind("mouseup", s), b.bind("selectstart", c), 
            n.preventDefault && n.preventDefault(), !0;
        }
    };
    e.extend(!0, e.fn.zTree.consts, t), e.extend(!0, e.fn.zTree._z, {
        tools: {
            getAbs: function(e) {
                return e = e.getBoundingClientRect(), [ e.left, e.top ];
            },
            inputFocus: function(e) {
                e.get(0) && (e.focus(), o.setCursorPosition(e.get(0), e.val().length));
            },
            inputSelect: function(e) {
                e.get(0) && (e.focus(), e.select());
            },
            setCursorPosition: function(e, t) {
                if (e.setSelectionRange) e.focus(), e.setSelectionRange(t, t); else if (e.createTextRange) {
                    var n = e.createTextRange();
                    n.collapse(!0), n.moveEnd("character", t), n.moveStart("character", t), n.select();
                }
            },
            showIfameMask: function(t, n) {
                for (var a = i.getRoot(t); a.dragMaskList.length > 0; ) a.dragMaskList[0].remove(), 
                a.dragMaskList.shift();
                if (n) for (var r = e("iframe"), d = 0, l = r.length; d < l; d++) {
                    var s = r.get(d), c = o.getAbs(s);
                    (s = e("<div id='zTreeMask_" + d + "' class='zTreeMask' style='top:" + c[1] + "px; left:" + c[0] + "px; width:" + s.offsetWidth + "px; height:" + s.offsetHeight + "px;'></div>")).appendTo("body"), 
                    a.dragMaskList.push(s);
                }
            }
        },
        view: {
            addEditBtn: function(t, n) {
                if (!(n.editNameFlag || e("#" + n.tId + r.id.EDIT).length > 0) && o.apply(t.edit.showRenameBtn, [ t.treeId, n ], t.edit.showRenameBtn)) {
                    var a = e("#" + n.tId + r.id.A), i = "<span class='button edit' id='" + n.tId + r.id.EDIT + "' title='" + o.apply(t.edit.renameTitle, [ t.treeId, n ], t.edit.renameTitle) + "' treeNode" + r.id.EDIT + " style='display:none;'></span>";
                    a.append(i), e("#" + n.tId + r.id.EDIT).bind("click", function() {
                        return !(!o.uCanDo(t) || 0 == o.apply(t.callback.beforeEditName, [ t.treeId, n ], !0)) && (d.editNode(t, n), 
                        !1);
                    }).show();
                }
            },
            addRemoveBtn: function(t, n) {
                if (!(n.editNameFlag || e("#" + n.tId + r.id.REMOVE).length > 0) && o.apply(t.edit.showRemoveBtn, [ t.treeId, n ], t.edit.showRemoveBtn)) {
                    var a = e("#" + n.tId + r.id.A), i = "<span class='button remove' id='" + n.tId + r.id.REMOVE + "' title='" + o.apply(t.edit.removeTitle, [ t.treeId, n ], t.edit.removeTitle) + "' treeNode" + r.id.REMOVE + " style='display:none;'></span>";
                    a.append(i), e("#" + n.tId + r.id.REMOVE).bind("click", function() {
                        return !(!o.uCanDo(t) || 0 == o.apply(t.callback.beforeRemove, [ t.treeId, n ], !0)) && (d.removeNode(t, n), 
                        t.treeObj.trigger(r.event.REMOVE, [ t.treeId, n ]), !1);
                    }).bind("mousedown", function() {
                        return !0;
                    }).show();
                }
            },
            addHoverDom: function(e, t) {
                i.getRoot(e).showHoverDom && (t.isHover = !0, e.edit.enable && (d.addEditBtn(e, t), 
                d.addRemoveBtn(e, t)), o.apply(e.view.addHoverDom, [ e.treeId, t ]));
            },
            cancelCurEditNode: function(t, n) {
                var a = i.getRoot(t), l = t.data.key.name, s = a.curEditNode;
                if (s) {
                    var c = a.curEditInput, u = n || c.val();
                    if (!n && !1 === o.apply(t.callback.beforeRename, [ t.treeId, s, u ], !0)) return !1;
                    s[l] = u || c.val(), n || t.treeObj.trigger(r.event.RENAME, [ t.treeId, s ]), e("#" + s.tId + r.id.A).removeClass(r.node.CURSELECTED_EDIT), 
                    c.unbind(), d.setNodeName(t, s), s.editNameFlag = !1, a.curEditNode = null, a.curEditInput = null, 
                    d.selectNode(t, s, !1);
                }
                return a.noSelection = !0;
            },
            editNode: function(t, n) {
                var a = i.getRoot(t);
                if (d.editNodeBlur = !1, i.isSelectedNode(t, n) && a.curEditNode == n && n.editNameFlag) setTimeout(function() {
                    o.inputFocus(a.curEditInput);
                }, 0); else {
                    var l = t.data.key.name;
                    n.editNameFlag = !0, d.removeTreeDom(t, n), d.cancelCurEditNode(t), d.selectNode(t, n, !1), 
                    e("#" + n.tId + r.id.SPAN).html("<input type=text class='rename' id='" + n.tId + r.id.INPUT + "' treeNode" + r.id.INPUT + " >");
                    var s = e("#" + n.tId + r.id.INPUT);
                    s.attr("value", n[l]), t.edit.editNameSelectAll ? o.inputSelect(s) : o.inputFocus(s), 
                    s.bind("blur", function() {
                        d.editNodeBlur || d.cancelCurEditNode(t);
                    }).bind("keydown", function(e) {
                        "13" == e.keyCode ? (d.editNodeBlur = !0, d.cancelCurEditNode(t, null, !0)) : "27" == e.keyCode && d.cancelCurEditNode(t, n[l]);
                    }).bind("click", function() {
                        return !1;
                    }).bind("dblclick", function() {
                        return !1;
                    }), e("#" + n.tId + r.id.A).addClass(r.node.CURSELECTED_EDIT), a.curEditInput = s, 
                    a.noSelection = !1, a.curEditNode = n;
                }
            },
            moveNode: function(t, n, a, o, l, s) {
                var c = i.getRoot(t), u = t.data.key.children;
                if (n != a && (!t.data.keep.leaf || !n || n.isParent || o != r.move.TYPE_INNER)) {
                    var h = a.parentTId ? a.getParentNode() : c;
                    (v = null === n || n == c) && null === n && (n = c), v && (o = r.move.TYPE_INNER), 
                    c = n.parentTId ? n.getParentNode() : c, o != r.move.TYPE_PREV && o != r.move.TYPE_NEXT && (o = r.move.TYPE_INNER), 
                    o == r.move.TYPE_INNER && (v ? a.parentTId = null : (n.isParent || (n.isParent = !0, 
                    n.open = !!n.open, d.setNodeLineIcos(t, n)), a.parentTId = n.tId));
                    var p;
                    v ? p = v = t.treeObj : (s || o != r.move.TYPE_INNER ? s || d.expandCollapseNode(t, n.getParentNode(), !0, !1) : d.expandCollapseNode(t, n, !0, !1), 
                    v = e("#" + n.tId), p = e("#" + n.tId + r.id.UL), v.get(0) && !p.get(0) && (p = [], 
                    d.makeUlHtml(t, n, p, ""), v.append(p.join(""))), p = e("#" + n.tId + r.id.UL));
                    var f = e("#" + a.tId);
                    f.get(0) ? v.get(0) || f.remove() : f = d.appendNodes(t, a.level, [ a ], null, !1, !0).join(""), 
                    p.get(0) && o == r.move.TYPE_INNER ? p.append(f) : v.get(0) && o == r.move.TYPE_PREV ? v.before(f) : v.get(0) && o == r.move.TYPE_NEXT && v.after(f);
                    var g = -1, N = 0, k = null, v = null, C = a.level;
                    if (a.isFirstNode) g = 0, h[u].length > 1 && (k = h[u][1], k.isFirstNode = !0); else if (a.isLastNode) g = h[u].length - 1, 
                    k = h[u][g - 1], k.isLastNode = !0; else for (p = 0, f = h[u].length; p < f; p++) if (h[u][p].tId == a.tId) {
                        g = p;
                        break;
                    }
                    if (g >= 0 && h[u].splice(g, 1), o != r.move.TYPE_INNER) for (p = 0, f = c[u].length; p < f; p++) c[u][p].tId == n.tId && (N = p);
                    o == r.move.TYPE_INNER ? (n[u] || (n[u] = []), n[u].length > 0 && (v = n[u][n[u].length - 1], 
                    v.isLastNode = !1), n[u].splice(n[u].length, 0, a), a.isLastNode = !0, a.isFirstNode = 1 == n[u].length) : n.isFirstNode && o == r.move.TYPE_PREV ? (c[u].splice(N, 0, a), 
                    v = n, v.isFirstNode = !1, a.parentTId = n.parentTId, a.isFirstNode = !0, a.isLastNode = !1) : n.isLastNode && o == r.move.TYPE_NEXT ? (c[u].splice(N + 1, 0, a), 
                    v = n, v.isLastNode = !1, a.parentTId = n.parentTId, a.isFirstNode = !1, a.isLastNode = !0) : (o == r.move.TYPE_PREV ? c[u].splice(N, 0, a) : c[u].splice(N + 1, 0, a), 
                    a.parentTId = n.parentTId, a.isFirstNode = !1, a.isLastNode = !1), i.fixPIdKeyValue(t, a), 
                    i.setSonNodeLevel(t, a.getParentNode(), a), d.setNodeLineIcos(t, a), d.repairNodeLevelClass(t, a, C), 
                    !t.data.keep.parent && h[u].length < 1 ? (h.isParent = !1, h.open = !1, n = e("#" + h.tId + r.id.UL), 
                    o = e("#" + h.tId + r.id.SWITCH), u = e("#" + h.tId + r.id.ICON), d.replaceSwitchClass(h, o, r.folder.DOCU), 
                    d.replaceIcoClass(h, u, r.folder.DOCU), n.css("display", "none")) : k && d.setNodeLineIcos(t, k), 
                    v && d.setNodeLineIcos(t, v), t.check && t.check.enable && d.repairChkClass && (d.repairChkClass(t, h), 
                    d.repairParentChkClassWithSelf(t, h), h != a.parent && d.repairParentChkClassWithSelf(t, a)), 
                    s || d.expandCollapseParentNode(t, a.getParentNode(), !0, l);
                }
            },
            removeEditBtn: function(t) {
                e("#" + t.tId + r.id.EDIT).unbind().remove();
            },
            removeRemoveBtn: function(t) {
                e("#" + t.tId + r.id.REMOVE).unbind().remove();
            },
            removeTreeDom: function(e, t) {
                t.isHover = !1, d.removeEditBtn(t), d.removeRemoveBtn(t), o.apply(e.view.removeHoverDom, [ e.treeId, t ]);
            },
            repairNodeLevelClass: function(t, n, a) {
                if (a !== n.level) {
                    var t = e("#" + n.tId), o = e("#" + n.tId + r.id.A), d = e("#" + n.tId + r.id.UL), a = "level" + a, n = "level" + n.level;
                    t.removeClass(a), t.addClass(n), o.removeClass(a), o.addClass(n), d.removeClass(a), 
                    d.addClass(n);
                }
            }
        },
        event: {},
        data: {
            setSonNodeLevel: function(e, t, n) {
                if (n) {
                    var a = e.data.key.children;
                    if (n.level = t ? t.level + 1 : 0, n[a]) for (var t = 0, o = n[a].length; t < o; t++) n[a][t] && i.setSonNodeLevel(e, n, n[a][t]);
                }
            }
        }
    });
    var a = e.fn.zTree, o = a._z.tools, r = a.consts, d = a._z.view, i = a._z.data;
    i.exSetting({
        edit: {
            enable: !1,
            editNameSelectAll: !1,
            showRemoveBtn: !0,
            showRenameBtn: !0,
            removeTitle: "remove",
            renameTitle: "rename",
            drag: {
                autoExpandTrigger: !1,
                isCopy: !0,
                isMove: !0,
                prev: !0,
                next: !0,
                inner: !0,
                minMoveSize: 5,
                borderMax: 10,
                borderMin: -5,
                maxShowNodeNum: 5,
                autoOpenTime: 500
            }
        },
        view: {
            addHoverDom: null,
            removeHoverDom: null
        },
        callback: {
            beforeDrag: null,
            beforeDragOpen: null,
            beforeDrop: null,
            beforeEditName: null,
            beforeRename: null,
            onDrag: null,
            onDrop: null,
            onRename: null
        }
    }), i.addInitBind(function(e) {
        var t = e.treeObj, n = r.event;
        t.bind(n.RENAME, function(t, n, a) {
            o.apply(e.callback.onRename, [ t, n, a ]);
        }), t.bind(n.REMOVE, function(t, n, a) {
            o.apply(e.callback.onRemove, [ t, n, a ]);
        }), t.bind(n.DRAG, function(t, n, a, r) {
            o.apply(e.callback.onDrag, [ n, a, r ]);
        }), t.bind(n.DROP, function(t, n, a, r, d, i, l) {
            o.apply(e.callback.onDrop, [ n, a, r, d, i, l ]);
        });
    }), i.addInitUnBind(function(e) {
        var e = e.treeObj, t = r.event;
        e.unbind(t.RENAME), e.unbind(t.REMOVE), e.unbind(t.DRAG), e.unbind(t.DROP);
    }), i.addInitCache(function() {}), i.addInitNode(function(e, t, n) {
        n && (n.isHover = !1, n.editNameFlag = !1);
    }), i.addInitProxy(function(e) {
        var t = e.target, a = i.getSetting(e.data.treeId), d = e.relatedTarget, l = "", s = null, c = "", u = null, h = null;
        if (o.eqs(e.type, "mouseover") ? (h = o.getMDom(a, t, [ {
            tagName: "a",
            attrName: "treeNode" + r.id.A
        } ])) && (l = h.parentNode.id, c = "hoverOverNode") : o.eqs(e.type, "mouseout") ? (h = o.getMDom(a, d, [ {
            tagName: "a",
            attrName: "treeNode" + r.id.A
        } ])) || (l = "remove", c = "hoverOutNode") : o.eqs(e.type, "mousedown") && (h = o.getMDom(a, t, [ {
            tagName: "a",
            attrName: "treeNode" + r.id.A
        } ])) && (l = h.parentNode.id, c = "mousedownNode"), l.length > 0) switch (s = i.getNodeCache(a, l), 
        c) {
          case "mousedownNode":
            u = n.onMousedownNode;
            break;

          case "hoverOverNode":
            u = n.onHoverOverNode;
            break;

          case "hoverOutNode":
            u = n.onHoverOutNode;
        }
        return {
            stop: !1,
            node: s,
            nodeEventType: c,
            nodeEventCallback: u,
            treeEventType: "",
            treeEventCallback: null
        };
    }), i.addInitRoot(function(e) {
        (e = i.getRoot(e)).curEditNode = null, e.curEditInput = null, e.curHoverNode = null, 
        e.dragFlag = 0, e.dragNodeShowBefore = [], e.dragMaskList = [], e.showHoverDom = !0;
    }), i.addZTreeTools(function(t, n) {
        n.cancelEditName = function(e) {
            var n = i.getRoot(t), a = t.data.key.name, o = n.curEditNode;
            n.curEditNode && d.cancelCurEditNode(t, e || o[a]);
        }, n.copyNode = function(e, n, a, i) {
            if (!n) return null;
            if (e && !e.isParent && t.data.keep.leaf && a === r.move.TYPE_INNER) return null;
            var l = o.clone(n);
            return e || (e = null, a = r.move.TYPE_INNER), a == r.move.TYPE_INNER ? (n = function() {
                d.addNodes(t, e, [ l ], i);
            }, o.canAsync(t, e) ? d.asyncNode(t, e, i, n) : n()) : (d.addNodes(t, e.parentNode, [ l ], i), 
            d.moveNode(t, e, l, a, !1, i)), l;
        }, n.editName = function(e) {
            e && e.tId && e === i.getNodeCache(t, e.tId) && (e.parentTId && d.expandCollapseParentNode(t, e.getParentNode(), !0), 
            d.editNode(t, e));
        }, n.moveNode = function(n, a, i, l) {
            function s() {
                d.moveNode(t, n, a, i, !1, l);
            }
            return a ? n && !n.isParent && t.data.keep.leaf && i === r.move.TYPE_INNER ? null : n && (a.parentTId == n.tId && i == r.move.TYPE_INNER || e("#" + a.tId).find("#" + n.tId).length > 0) ? null : (n || (n = null), 
            o.canAsync(t, n) ? d.asyncNode(t, n, l, s) : s(), a) : a;
        }, n.setEditable = function(e) {
            return t.edit.enable = e, this.refresh();
        };
    });
    var l = d.cancelPreSelectedNode;
    d.cancelPreSelectedNode = function(e, t) {
        for (var n = i.getRoot(e).curSelectedList, a = 0, o = n.length; a < o && (t && t !== n[a] || (d.removeTreeDom(e, n[a]), 
        !t)); a++) ;
        l && l.apply(d, arguments);
    };
    var s = d.createNodes;
    d.createNodes = function(e, t, n, a) {
        s && s.apply(d, arguments), n && d.repairParentChkClassWithSelf && d.repairParentChkClassWithSelf(e, a);
    };
    var c = d.makeNodeUrl;
    d.makeNodeUrl = function(e, t) {
        return e.edit.enable ? null : c.apply(d, arguments);
    };
    var u = d.removeNode;
    d.removeNode = function(e, t) {
        var n = i.getRoot(e);
        n.curEditNode === t && (n.curEditNode = null), u && u.apply(d, arguments);
    };
    var h = d.selectNode;
    d.selectNode = function(e, t, n) {
        var a = i.getRoot(e);
        return (!i.isSelectedNode(e, t) || a.curEditNode != t || !t.editNameFlag) && (h && h.apply(d, arguments), 
        d.addHoverDom(e, t), !0);
    };
    var p = o.uCanDo;
    o.uCanDo = function(e, t) {
        var n = i.getRoot(e);
        return !(!t || !(o.eqs(t.type, "mouseover") || o.eqs(t.type, "mouseout") || o.eqs(t.type, "mousedown") || o.eqs(t.type, "mouseup"))) || !n.curEditNode && (!p || p.apply(d, arguments));
    };
}(jQuery);